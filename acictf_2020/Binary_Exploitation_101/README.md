# Binary Exploitation 101 #

**Category:**	Binary Exploitation  
**Points:**	50

**Prompt:** 
* Exploiting bugs in programs can definitely be difficult. Not only do you need a certain amount of reverse engineering required to identify vulnerabilities, but you also need to weaponize that vulnerability somehow. To get new hackers started, we included our annotated [source code](./BinEx101.c) along with the compiled [program](./BinEx101).
* If you don't know where to start, download the source code and open it in a program with syntax highlighting such as notepad++ or gedit. If you don't have the ability to use either of those, you can always use vim.
* You can connect to the problem at telnet challenge.acictf.com 12095 or nc challenge.acictf.com 12095

**Hints:** 
* Signed integers on modern computers generally use something called ["Two's Complement"](https://en.wikipedia.org/wiki/Two%27s_complement) for representing them. If this is your first time dealing with integers at this level, it is probably worth taking some time to get a basic understanding of them. In particular, you will need to understand what the largest positive number looks like, what -1 looks like, and how [overflow](https://en.wikipedia.org/wiki/Integer_overflow) is generally "handled".
* We've also included debug symbols in the binary and disabled compiler optimizations. Once you understand how the C code works from the source code, it is probably worth opening the compiled binary in something like [Ghidra](https://ghidra-sre.org/) to see both what the assembly looks like and how the recovered C code compares to the source code. Most of the other binary exploitation problems do not give you access to the raw source code.
* While many binary exploitation situations involve "non-standard" inputs (such as feeding shellcode as input to the name of something), this challenge does not. Once you understand the vulnerability, you can trigger it through normal interaction with the challenge. If you are having trouble on the math side, treating the binary representation of your 'target' number as an unsigned integer may be helpful.
* If you are new to binary exploitation (or C code), we really recommend reading the source file in its entirety as the comments try to explain many of the key concepts for this category of problems. For this specific problem, anyone not familiar C should definitely read the source file because the behavior of s.numbers[-1] is very different between C and some other popular languages (e.g. Python).

**Solution:**
* FFFFFFFF in twos compliment is -1.  Unsigned, it equals 4294967295.  To overflow, we need to multiply two numbers to get that.
* 4294967295 / 3 = 1431655765
* ACI{25d99e015cd93139ecc52aba33e}
